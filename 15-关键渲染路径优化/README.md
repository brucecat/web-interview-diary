# 渲染路径

1、处理HTML标记并构建DOM树

2、处理CSS标记并构建CSSOM树

3、将DOM与CSSOM合并成一个render tree

4、根据渲染树来布局，以计算每个节点的几何信息

5、将各个节点绘制到屏幕上





优化，从三个方面入手

- 关键资源的数量

- 关键路径长度

- 关键字节的数量







### 优化HTML

- 缩小文件尺寸
- 使用gzip压缩
- 使用缓存



### 优化CSS

- 尽量避免在css中使用@import

  会造成依赖路径变长

阻塞渲染: 当浏览器遇到一个 `<link> `标签引用外部CSS文件时，它会暂停页面的渲染，直到该CSS文件被下载并解析完成。这被称为“渲染阻塞资源”。这意味着在CSS文件加载和解析完成之前，页面上的元素将不会被渲染。

内联CSS: 如果CSS样式是直接内联在HTML文档中的（例如，使用 <style> 标签），则不会阻塞页面渲染，因为它们是与HTML一起下载的。

异步加载: 通过使用 async 或 defer 属性在 <link> 标签上，可以减少CSS文件对页面渲染的阻塞。async 允许CSS文件异步加载，但浏览器仍然需要等待它解析完成后才能渲染页面。defer 则允许浏览器在解析HTML后异步加载CSS，但会在文档解析完成后立即应用样式。

关键渲染路径: 浏览器会构建一个“关键渲染路径”，这是从开始加载页面到首次绘制内容到屏幕上的一系列步骤。CSS是这个路径上的一个重要环节，因为它定义了页面的视觉样式。

渲染树构建: 浏览器首先解析HTML来构建DOM树，然后解析CSS来构建CSSOM（CSS对象模型）。这两个模型结合在一起形成渲染树，然后浏览器根据渲染树来布局和绘制页面。

性能优化: 为了减少CSS对页面渲染的阻塞，可以采取一些性能优化措施，如：

- 将关键CSS内联到HTML文档中，以减少HTTP请求并加快首次渲染。
- 使用媒体查询加载非关键CSS，例如只在打印时加载打印样式。
- 压缩CSS文件以减少文件大小和加载时间。
- 使用HTTP/2，它允许并行传输多个资源，从而减少渲染阻塞。




### 优化JS

- 异步加载Javascript
- 避免同步请求
- 延迟解析javascript
- 避免运行时间长的javascript



**async**

- 作用：异步加载脚本，不阻塞页面解析，加载完成后立即执行。
- 使用场景：当脚本不依赖于其他脚本，且不需要在 DOM 完全加载后执行时使用。

```js
<script src="example.js" async></script>
```

**defer**

- 作用：延迟脚本的执行，直到文档解析完成后，按照它们在文档中出现的顺序执行。
- 使用场景：当脚本之间存在依赖关系，或者脚本需要在 DOM 完全加载后执行时使用。

```js
<script src="example.js" defer></script>
```

**preload**

- 作用：告诉浏览器某个资源是接下来会用到的，浏览器会根据当前页面的上下文决定是否提前加载。
- 使用场景：预加载那些页面加载后不久就会用到的资源，如字体文件、图片、样式表或脚本。

```js
<link rel="preload" href="example.js" as="script">
```

**prefetch**

- 作用：告诉浏览器某个资源是未来页面可能会用到的，浏览器会在空闲时进行加载。
- 使用场景：预获取那些可能在后续页面中使用，但当前页面不需要的资源，如下一个页面的脚本或样式。

```js
<link rel="prefetch" href="next-page.js">
```



**放在 `<head>` 中**

- 脚本会按照它们在HTML文档中出现的顺序执行。
- 如果没有使用 `async` 或 `defer` 属性，脚本的加载和执行会阻塞页面的解析。这意味着浏览器会停止构建DOM，直到脚本加载并执行完成。
- 这可能导致首屏渲染的延迟，因为浏览器必须等待脚本下载和执行才能继续渲染页面。



**放在 `<body>` 中**

- 如果脚本没有 `async` 或 `defer` 属性，它们会在文档的解析过程中被遇到，并且会立即下载和执行，但这通常发生在解析 `<body>` 的过程中。
- 将脚本放在 `<body>` 的底部，接近 `</body>` 标签，可以确保在脚本执行前页面的DOM已经完全构建，这有助于避免因脚本执行而导致的DOM操作错误。



**requestAnimationFrame**

`requestAnimationFrame` 是一个 Web API，它允许你创建平滑的动画。这个函数告诉浏览器你想要执行一个动画，并请求浏览器在下一次重绘之前调用你的回调函数。它比传统的 `setTimeout` 和 `setInterval` 更适合动画，因为它与浏览器的重绘同步，可以提供更流畅和性能更好的动画效果。





**WebWorker**

Web Workers 允许你在 Web 应用程序中运行脚本在后台线程上，而不会干扰主执行线程。

Web Workers 有一些限制：

- Workers 无法访问 DOM。
- Workers 之间无法直接通信，它们需要通过主线程来传递消息。
- 你不能在 Worker 中创建新的 Worker（子线程），但可以创建多个 Worker 并与它们通信。